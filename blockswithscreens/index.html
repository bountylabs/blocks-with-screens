<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 8px 0;
      }
    </style>
  </head>

  <body>
    <h2>Input</h2>

    <input type="file" name="input" id="input" onchange="onInputSource()" />
    <button onclick="cameraCapture()">Camera Capture</button>

    <h4>Options</h4>
    <label>
      <input id="fillInput" type="checkbox" name="fillInput" checked />
      Fill
    </label>

    <div style="border: 1px solid red;">
      <video
        id="video"
        style="width: 100%;"
        autoplay
        loop
        muted
        playsinline
      ></video>
      <img id="image" style="width: 100%;" />
    </div>

    <h2>Output</h2>
    <canvas id="canvas" style="width: 100%; border: 1px solid green;"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script>
      const SIZE = 128;
      const PIXELS = SIZE * SIZE;
      const FILETYPE_REGEX = /(.*)\//;

      const video = document.getElementById('video');
      const image = document.getElementById('image');
      const input = document.getElementById('input');
      const fillInput = document.getElementById('fillInput');
      const canvas = document.getElementById('canvas');
      const context = canvas.getContext('2d');

      let rafID = 0;

      canvas.width = canvas.height = SIZE;

      function time(label, operation) {
        console.time(label);
        const start = performance.now();

        operation();

        console.timeEnd(label);

        const end = performance.now();
        const time = end - start;
        console.info(label, { time });
      }

      function resetAllInputs() {
        delete image.src;
        delete video.src;
        video.style.display = 'none';
        image.style.display = 'none';
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
        }
        context.clearRect(0, 0, canvas.width, canvas.height);
      }

      function cameraCapture() {
        resetAllInputs();

        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
          video.style.display = 'block';
          video.srcObject = stream;
          video.load();

          video.onloadeddata = () => {
            drawCanvas(video, {
              width: video.videoWidth,
              height: video.videoHeight,
              raf: true,
              fill: fillInput.checked,
            });
          };
        });
      }

      function onInputSource() {
        resetAllInputs();

        const inputFile = input.files[0];

        if (!inputFile) {
          return console.error('no files input');
        }

        // setup blob url
        const url = URL.createObjectURL(inputFile);

        // determine video or image
        const match = inputFile.type.match(FILETYPE_REGEX);
        if (!match || match.length < 2) {
          return console.error('Unable to identify file type', inputFile);
        }

        const type = match[1];
        switch (type) {
          case 'video':
            console.info('video detected');

            // setup video with url draw to canvas once loaded
            video.style.display = 'block';
            video.src = url;
            video.load();

            video.onloadeddata = () => {
              drawCanvas(video, {
                width: video.videoWidth,
                height: video.videoHeight,
                raf: true,
                fill: fillInput.checked,
              });
            };

            break;
          case 'image':
            console.info('image detected');

            // set image src and draw when loaded
            image.style.display = 'block';
            image.addEventListener('load', e => {
              EXIF.getData(image, function() {
                const metadata = EXIF.getAllTags(this);
                console.info({ metadata });
              });

              drawCanvas(image, {
                width: image.naturalWidth,
                height: image.naturalHeight,
                fill: fillInput.checked,
              });
            });
            image.src = url;

            break;
          default:
            console.error('unrecognized type', type, inputFile);
            return;
        }
      }

      function drawCanvas(source, options) {
        cancelAnimationFrame(rafID);
        const { width, height, raf = false, fill = false } = options;

        const ratioFunction = fill ? Math.max : Math.min;
        const ratio = ratioFunction(SIZE / width, SIZE / height);

        const proportionalHeight = ratio * height;
        const proportionalWidth = ratio * width;
        const heightDiff = SIZE - proportionalHeight;
        const widthDiff = SIZE - proportionalWidth;
        let xStart = 0;
        let yStart = 0;

        // split dimension diff across to center source
        if (fill || width > height) {
          yStart = heightDiff / 2;
        }
        if (fill || height > width) {
          xStart = widthDiff / 2;
        }

        // draw source to canvas proportionally
        context.drawImage(
          source,
          0,
          0,
          width,
          height,
          xStart,
          yStart,
          proportionalWidth,
          proportionalHeight
        );

        // draw again if raf
        if (raf) {
          rafID = requestAnimationFrame(() => {
            drawCanvas(source, options);
          });
        }
      }

      // convert canvas image data uint8 array to RGB565 format
      function canvasToRGB565() {
        // canvas Uint8Array uses 4 bytes per pixel (RGBA)
        const imgData = context.getImageData(0, 0, SIZE, SIZE).data;
        // RGB565 uses 2 bytes per pixel ([RRRRRGGG][GGGBBBBB])
        // this results in a Uint8 array of half the size
        const rgb565 = new Uint8Array(PIXELS * 2);

        for (let p = 0; p < PIXELS; p++) {
          // pixels are layed out as 4 bytes [R G B A]
          // so for a given pixel we will look at 4*p as
          // the start of array of RGBA values

          // extract RGB (ignore A)
          let r = imgData[p * 4 + 0];
          let g = imgData[p * 4 + 1];
          let b = imgData[p * 4 + 2];

          // if (r || g || b) {
          //   console.info({ r, g, b });
          // }

          // convert 8 bits to 5 bits (000RRRRR)
          r = r >> 3;
          // convert 8 bits to 6 bits (00GGGGGG)
          g = g >> 2;
          // convert 8 bits to 5 bits (000BBBBB)
          b = b >> 3;

          // RGB565 output format for LCD screen
          // 2 bytes per RGB pixel
          // [RRRRRGGG][GGGBBBBB]
          // r << 3 == shift 5 bits of r into top 5 bits of 8-bit value
          // 000RRRRR << 3 == RRRRR000
          // g >> 3 == shift 6 bits of g into bottom 3 bits of 8-bit value
          // 00GGGGGG >> 3 == 00000GGG
          // (r << 3) | (g >> 3)
          // RRRRR000 | 00000GGG == RRRRRGGG
          // g << 5 == shift 6 bits of g into top 3 bits of 8-bit value
          // 00GGGGGG << 5 == GGG00000
          // (g << 5) | b
          // GGG00000 | 000BBBBB == GGGBBBBB
          rgb565[p * 2 + 0] = (r << 3) | (g >> 3);
          rgb565[p * 2 + 1] = (g << 5) | b;
        }

        return rgb565;
      }
    </script>
  </body>
</html>
